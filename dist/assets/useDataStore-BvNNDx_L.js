import{R as I}from"./index-fFMlRtGA.js";const k=t=>{let s;const e=new Set,a=(c,m)=>{const f=typeof c=="function"?c(s):c;if(!Object.is(f,s)){const P=s;s=m??(typeof f!="object"||f===null)?f:Object.assign({},s,f),e.forEach(p=>p(s,P))}},r=()=>s,u={setState:a,getState:r,getInitialState:()=>d,subscribe:c=>(e.add(c),()=>e.delete(c))},d=s=t(a,r,u);return u},H=(t=>t?k(t):k),_=t=>t;function E(t,s=_){const e=I.useSyncExternalStore(t.subscribe,I.useCallback(()=>s(t.getState()),[t,s]),I.useCallback(()=>s(t.getInitialState()),[t,s]));return I.useDebugValue(e),e}const K=t=>{const s=H(t),e=a=>E(s,a);return Object.assign(e,s),e},O=(t=>t?K(t):K);function A(t,s){let e;try{e=t()}catch{return}return{getItem:r=>{var o;const g=d=>d===null?null:JSON.parse(d,void 0),u=(o=e.getItem(r))!=null?o:null;return u instanceof Promise?u.then(g):g(u)},setItem:(r,o)=>e.setItem(r,JSON.stringify(o,void 0)),removeItem:r=>e.removeItem(r)}}const b=t=>s=>{try{const e=t(s);return e instanceof Promise?e:{then(a){return b(a)(e)},catch(a){return this}}}catch(e){return{then(a){return this},catch(a){return b(a)(e)}}}},x=(t,s)=>(e,a,r)=>{let o={storage:A(()=>localStorage),partialize:n=>n,version:0,merge:(n,h)=>({...h,...n}),...s},g=!1;const u=new Set,d=new Set;let c=o.storage;if(!c)return t((...n)=>{console.warn(`[zustand persist middleware] Unable to update item '${o.name}', the given storage is currently unavailable.`),e(...n)},a,r);const m=()=>{const n=o.partialize({...a()});return c.setItem(o.name,{state:n,version:o.version})},f=r.setState;r.setState=(n,h)=>(f(n,h),m());const P=t((...n)=>(e(...n),m()),a,r);r.getInitialState=()=>P;let p;const y=()=>{var n,h;if(!c)return;g=!1,u.forEach(i=>{var S;return i((S=a())!=null?S:P)});const v=((h=o.onRehydrateStorage)==null?void 0:h.call(o,(n=a())!=null?n:P))||void 0;return b(c.getItem.bind(c))(o.name).then(i=>{if(i)if(typeof i.version=="number"&&i.version!==o.version){if(o.migrate){const S=o.migrate(i.state,i.version);return S instanceof Promise?S.then(w=>[!0,w]):[!0,S]}console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,i.state];return[!1,void 0]}).then(i=>{var S;const[w,R]=i;if(p=o.merge(R,(S=a())!=null?S:P),e(p,!0),w)return m()}).then(()=>{v?.(p,void 0),p=a(),g=!0,d.forEach(i=>i(p))}).catch(i=>{v?.(void 0,i)})};return r.persist={setOptions:n=>{o={...o,...n},n.storage&&(c=n.storage)},clearStorage:()=>{c?.removeItem(o.name)},getOptions:()=>o,rehydrate:()=>y(),hasHydrated:()=>g,onHydrate:n=>(u.add(n),()=>{u.delete(n)}),onFinishHydration:n=>(d.add(n),()=>{d.delete(n)})},o.skipHydration||y(),p||P},J=x;function D(t,s){return s===0?0:t/s}function M(t,s){const e=t.length;let a=0,r=0,o=0;const g=new Map(t.map(n=>[n.id,n.lengthKm??1]));for(const n of s){if(n.actualPhysicalPct==null&&n.plannedPhysicalPct==null)continue;const h=g.get(n.projectId)??1;a+=h,r+=(n.actualPhysicalPct??0)*h,o+=(n.plannedPhysicalPct??0)*h}const u=a?r/a:0,d=new Map;for(const n of s)d.set(n.projectId,n);let c=0,m=0;d.forEach(n=>{c+=n.cumulativeActual??0,m+=n.cumulativePlanned??0});const f=D(c,m)*100,P=c-m,p=D(P,m)*100;let y=0;return d.forEach(n=>{(n.actualPhysicalPct??0)-(n.plannedPhysicalPct??0)<-5&&(y+=1)}),{totalProjects:e,weightedPhysicalProgressPct:u,financialProgressPct:f,totalVarianceINR:P,variancePct:p,atRiskProjects:y}}const j=t=>new Promise(s=>setTimeout(s,t));class N{projects=[];points=[];async loadSamples(){await j(200),this.projects=[{id:"P1",name:"Sample Project 1",lengthKm:50,state:"MH"},{id:"P2",name:"Sample Project 2",lengthKm:30,state:"GJ"}],this.points=[{projectId:"P1",date:"2025-07-01",plannedPhysicalPct:40,actualPhysicalPct:38,cumulativePlanned:100,cumulativeActual:95},{projectId:"P2",date:"2025-07-01",plannedPhysicalPct:35,actualPhysicalPct:28,cumulativePlanned:80,cumulativeActual:70}]}async getProjects(){return await j(100),this.projects}async getPoints(){return await j(100),this.points}async getKPIs(){return await j(100),M(this.projects,this.points)}setData(s,e){this.projects=s,this.points=e}}const l=new N,B=O()(J((t,s)=>({projects:[],points:[],kpi:void 0,loading:!1,currentSource:"sample",uploadedProjects:[],uploadedPoints:[],loadSamples:async()=>{t({loading:!0}),await l.loadSamples();const[e,a,r]=await Promise.all([l.getProjects(),l.getPoints(),l.getKPIs()]);t({projects:e,points:a,kpi:r,loading:!1,currentSource:"sample"})},setData:(e,a)=>{l.setData(e,a),t({projects:e,points:a,uploadedProjects:e,uploadedPoints:a,currentSource:"uploaded"}),l.getKPIs().then(r=>t({kpi:r})).catch(()=>{})},refreshKPIs:async()=>{const e=await l.getKPIs();t({kpi:e})},switchToSample:async()=>{t({loading:!0}),await l.loadSamples();const[e,a,r]=await Promise.all([l.getProjects(),l.getPoints(),l.getKPIs()]);t({projects:e,points:a,kpi:r,loading:!1,currentSource:"sample"})},switchToUploaded:async()=>{const{uploadedProjects:e,uploadedPoints:a}=s();if(e.length===0&&a.length===0)return;l.setData(e,a),t({projects:e,points:a,currentSource:"uploaded"});const r=await l.getKPIs();t({kpi:r})}}),{name:"highwayexec-data"}));export{B as u};
